{% extends 'base.html' %}

{% block content %}
 
{% load static %}
{% block extra_head %}
<link rel="stylesheet" href="{% static 'css/canvas.css' %}">
 
{% endblock %}

<form id="canvas-form">
    {% csrf_token %}

    {% if is_editing %}
        <input type="hidden" id="canvasId" value="{{ canvas.id }}">
    {% endif %}

    <div class="change p-4 black-border mt-3">
        <input type="text" id="userText" placeholder="Your Text" value="word upp">
        <input type="color" id="textColor" value="#ffffff">
        <label for="horizontalSlider">H Collumns</label>
        <input type="range" id="horizontalSlider" min="0" max="100" value="2">
        <label for="verticalSlider">V Rows</label>
        <input type="range" id="verticalSlider" min="0" max="100" value="1">    
    </div>

    <div class="nochange p-4 black-border">
        <label for="bgColor">bgColor</label>
        <input type="color" id="bgColor" value="#000000">
        <label for="brushColor">brushColor</label>
        <input type="color" id="brushColor">
        <label for="horizontalSpacing">H spacing</label>
        <input type="range" id="horizontalSpacing" min="0" max="100" value="0">
        <label for="verticalSpacing">V Spacing</label>
        <input type="range" id="verticalSpacing" min="0" max="100" value="0">

    </div>

    <div class="thework p-4 black-border">
        <input type="text" id="canvasName" placeholder="Canvas Name" value="untitled">
        <button type="button" onclick="saveCanvasState()">Save</button>
        <button type="button" onclick="loadCanvasState()">Load</button>
    </div>

  </form>

<div id="canvas-container"></div>

{% include "loadedit.html" %}

<script>
let userText;
let textColor;
let bgColor;
let horizontalSlider;
let verticalSlider;
let brushColor;
let wordObjects = [];
let horizontalSpacing;
let verticalSpacing;
let inputWords =[];

function setup() {
    console.log("Setup running...")
    let canvas = createCanvas(400, 400);
    canvas.parent('canvas-container');
    userText = select('#userText');
    textColor = select('#textColor');
    bgColor = select('#bgColor');
    horizontalSlider = select('#horizontalSlider');
    verticalSlider = select('#verticalSlider');
    brushColor = select('#brushColor');
    horizontalSpacing = select('#horizontalSpacing');
    verticalSpacing = select('#verticalSpacing');

    //  resetting actions
    userText.input(handleResettingAction);
    horizontalSlider.input(updateWords2);
    verticalSlider.input(updateWords2);
    textColor.input(updateTextColor);

    // Non-resetting actions
 
    bgColor.input(updateBackgroundColor);
    horizontalSpacing.input(updateSpacing2);
verticalSpacing.input(updateSpacing2);

    updateWords();
    noLoop()
}

function draw() {
    // console.log("Drawing...");  // Debugging line
  background(bgColor.value());
  textSize(32);
  textAlign(CENTER, CENTER);

  // Draw each word with its own color
  for (const word of wordObjects) {
    // background(bgColor.value());
    fill(word.color);
    text(word.text, word.x, word.y);
  }
  
}

let isMousePressed = false; 

function mousePressed() {
  isMousePressed = true;
  
  for (const word of wordObjects) {
    let d = dist(mouseX, mouseY, word.x, word.y);
    
    let textW = textWidth(word.text);
    let textH = textAscent() + textDescent();
    let dynamicThreshold = Math.max(textW, textH) / 2;
    
    if (d < dynamicThreshold/2) {
      word.color = brushColor.value();
    }
  }
  redraw();  // Force p5.js to execute draw()
}



function mouseDragged() {
  // Similar logic to mousePressed
  if (isMousePressed) {
    for (const word of wordObjects) {
      let d = dist(mouseX, mouseY, word.x, word.y);
      
      // Get dynamic dimensions
      let textW = textWidth(word.text);
      let textH = textAscent() + textDescent();
      let dynamicThreshold = Math.max(textW, textH) / 2;
      
      if (d < dynamicThreshold/2) {
        word.color = brushColor.value();
      }
    }
    redraw(); // Force the canvas to update
  }
  redraw();  // Force p5.js to execute draw()
}


function mouseReleased() {
  isMousePressed = false;
}

let isEditing = false;  // Add this global variable

function updateWords() {
    const words = userText.value().split(" ");
    let newWordPositions = calculateWordPositions(words);

    // Store the existing wordObjects array
    let oldWordObjects = [...wordObjects];

    // Clear and populate the wordObjects array with new positions
    wordObjects = [];

    for (const {x, y, word} of newWordPositions) {
        // Check if this word was in the old array
        let oldWord = oldWordObjects.find(w => w.text === word);
        let colorToUse = oldWord ? oldWord.color : textColor.value();

        wordObjects.push({
            text: word,
            x: x,
            y: y,
            color: colorToUse
        });
    }
 
    redraw();  // Redraw the canvas
}


function updateWords2(data) {
    if (data.word_objects && Array.isArray(data.word_objects)) {
        let wordsFromData = data.word_objects.map(obj => obj.text);
        let newWordPositions = calculateWordPositions(wordsFromData);

        wordObjects = [];

        for (let i = 0; i < newWordPositions.length; i++) {
            let word = newWordPositions[i].word;

            // Find the original word in data.word_objects to get its color
            let originalWordObject = data.word_objects.find(w => w.text === word);

            let colorToUse = originalWordObject ? originalWordObject.color : textColor.value();

            wordObjects.push({
                text: word,
                x: newWordPositions[i].x,
                y: newWordPositions[i].y,
                color: colorToUse
            });
        }
        redraw();  // Redraw the canvas
    }
}




 
</script>



<script>


function handleResettingAction() {
    inputWords = userText.value().split(" ");  // Split the input into words here
    // wordObjects = calculateWordPositions();  // Update the positions

    wordObjects = [];  // Clear the array
    updateWords();  // Populate it based on new settings
    redraw();  // Redraw the canvas
}

 

function handleNonResettingAction() {
    const words = userText.value().split(" ");
    let newWordPositions = calculateWordPositions(words);
    // background(bgColor.value());
    for (const {x, y, word} of newWordPositions) {
        text(word, x, y);
    }

    redraw();  // Force a redraw
}



function updateTextColor() {
  const newColor = textColor.value();

  for (const word of wordObjects) {
    word.color = newColor;
  }
  redraw();  // Redraw the canvas
}




function calculateWordPositions(words) {
  let newWordPositions = [];
  let vLines = int(verticalSlider.value());
  let hLines = int(horizontalSlider.value());
  let hSpacing = int(horizontalSpacing.value());
  let vSpacing = int(verticalSpacing.value());
  let averageWordWidth = 0;

  // Calculate average word width
  for (let word of words) {
    averageWordWidth += textWidth(word);
  }
  averageWordWidth /= words.length;

  for (let i = -vLines; i <= vLines; i++) {
    for (let j = -hLines; j <= hLines; j++) {
      let x = width / 2 + textSize();
      let y = height / 2 + i * (textSize() + vSpacing);

      let totalWidth = averageWordWidth * words.length + hSpacing * (words.length - 1);
      
      // Adjust for the horizontal repetitions
      x += j * (totalWidth + hSpacing);

      // Adjust for centering the grid
      let gridCenter = totalWidth / 2 + hSpacing * (hLines - j);
      let startX = x - gridCenter;

      for (let word of words) {
        newWordPositions.push({ x: startX, y: y, word: word });
        startX += textWidth(word) + hSpacing - (textWidth(word) - averageWordWidth);
      }
    }
  }

  return newWordPositions;
}






// Function to update the spacing
function updateSpacing() {
  // Reset wordObjects array
  wordObjects = [];
  // Get the words from the user's input
  const words = userText.value().split(" ");
  // Calculate new positions for these words
  const newWordPositions = calculateWordPositions(words);

  // Populate wordObjects with the new positions
  for (const {x, y, word} of newWordPositions) {
    wordObjects.push({
      text: word,
      x: x,
      y: y,
      color: textColor.value()
    });
  }

  // Force a redraw
  redraw();
}


function updateSpacing2(wordObjects) {
  // Use the global wordObjects
  let wordsFromData = wordObjects.map(obj => obj.text);

  // Calculate new positions
  let newWordPositions = calculateWordPositions(wordsFromData);

  // Store old state
  let oldWordObjects = [...wordObjects];

  // Clear array
  wordObjects3 = [];

  // Populate with new positions
  for (let i = 0; i < newWordPositions.length; i++) {
    let word = newWordPositions[i].word;

    // Find original word to preserve color
    let originalWordObject = oldWordObjects.find(w => w.text === word);

    let colorToUse = originalWordObject ? originalWordObject.color : textColor.value();

    wordObjects3.push({
      text: word,
      x: newWordPositions[i].x,
      y: newWordPositions[i].y,
      color: colorToUse
    });
  }
  console.log("wordObjects before map:", wordObjects);
  // Force redraw
  redraw();
}




function updateBackgroundColor() {

  background(bgColor.value());
  redraw();  // Redraw the canvas
}



</script>

{% endblock %}