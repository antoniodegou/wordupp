{% extends 'base.html' %}

{% block content %}
 

 

<form id="canvas-form">
    {% csrf_token %}

    {% if is_editing %}
  <input type="hidden" id="canvasId" value="{{ canvas.id }}">
{% endif %}
    <input type="text" id="userText" placeholder="Your Text" value="wordupp">
    <input type="color" id="textColor" value="#ffffff">
    <input type="color" id="bgColor" value="#000000">

<!-- New sliders -->
<input type="range" id="horizontalSlider" min="0" max="100" value="0">
<input type="range" id="verticalSlider" min="0" max="100" value="0">
<input type="color" id="brushColor">


    <input type="text" id="canvasName" placeholder="Canvas Name" value="untitled">

    <button type="button" onclick="saveCanvasState()">Save</button>
    <button type="button" onclick="loadCanvasState()">Load</button>
    <!-- Add more buttons or fields as needed -->
  </form>

<div id="canvas-container"></div>

 

<script>
let userText;
let textColor;
let bgColor;
let horizontalSlider;
let verticalSlider;
let brushColor;
let wordObjects = [];

function setup() {
  let canvas = createCanvas(400, 400);
  canvas.parent('canvas-container');
  userText = select('#userText');
  textColor = select('#textColor');
  bgColor = select('#bgColor');
  horizontalSlider = select('#horizontalSlider');
  verticalSlider = select('#verticalSlider');
  brushColor = select('#brushColor');
  
  userText.input(handleResettingAction);
  horizontalSlider.input(handleResettingAction);
  verticalSlider.input(handleResettingAction);

  // Non-resetting actions
  textColor.input(handleNonResettingAction);
  bgColor.input(handleNonResettingAction);

  updateWords();
  noLoop();

 
  noLoop()
}

function draw() {
    // console.log("Drawing...");  // Debugging line
  background(bgColor.value());
  textSize(32);
  textAlign(CENTER, CENTER);

  // Draw each word with its own color
  for (const word of wordObjects) {
    fill(word.color);
    text(word.text, word.x, word.y);
  }
  
}

function mousePressed() {
  // Check if any word is clicked and update its color
  for (const word of wordObjects) {
    let d = dist(mouseX, mouseY, word.x, word.y);
    if (d < 20) {
      word.color = brushColor.value();
    }
  }
  redraw();  // Force p5.js to execute draw()

}
let isEditing = false;  // Add this global variable

function updateWords() {
    if (!isEditing) {
        wordObjects = [];  // Clear previous words
        
        let horizontalRepeats = int(horizontalSlider.value());
        let verticalRepeats = int(verticalSlider.value());

        let centerX = width / 2;
        let centerY = height / 2;
        let stepX = horizontalRepeats > 0 ? width / (horizontalRepeats * 2 + 1) : 0;
        let stepY = verticalRepeats > 0 ? height / (verticalRepeats * 2 + 1) : 0;

        // Create word objects based on current settings
        for (let i = -horizontalRepeats; i <= horizontalRepeats; i++) {
        for (let j = -verticalRepeats; j <= verticalRepeats; j++) {
            wordObjects.push({
            text: userText.value(),
            x: centerX + i * stepX,
            y: centerY + j * stepY,
            color: textColor.value()
            });
        }
        }
    }
  
    // Your existing code for drawing each word
    for (const wordObj of wordObjects) {
        fill(wordObj.color);  // Set the color
        text(wordObj.text, wordObj.x, wordObj.y);  // Draw the text
    }
}

 
</script>



<script>


const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    // Inside your <script> tag in create_canvas.html


window.onload = function() {
  // Your existing setup code here...

  // Check if we're in edit mode
  const canvasId = document.getElementById('canvasId');
  if (canvasId && canvasId.value) {
    // We're editing an existing canvas, load its state
    loadCanvasState(canvasId.value);
  }
}

function saveCanvasState() {
  const canvasData = {
    name: document.getElementById('canvasName').value,
    user_text: userText.value(),
    text_color: textColor.value(),
    bg_color: bgColor.value(),
    wordObjects: wordObjects
  };

  if (isEditing && document.getElementById('canvasId').value) {
    // Update existing canvas
    updateCanvasState(document.getElementById('canvasId').value, canvasData);
  } else {
    // Create a new canvas
    fetch('/wordupp/api/save/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrftoken,
      },
      body: JSON.stringify(canvasData),
    })
    .then(response => response.json())
    .then(data => {
      console.log("New canvas saved:", data);
    });
  }
}

function updateCanvasState(canvas_id, canvasData) {
  fetch(`/wordupp/api/update/${canvas_id}/`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': csrftoken,
    },
    body: JSON.stringify(canvasData),
  })
  .then(response => response.json())
  .then(data => {
    console.log("Existing canvas updated:", data);
  });
}



function loadCanvasState(canvas_id) {
    isEditing = true;  // We're in edit mode

  fetch(`/wordupp/api/load/${canvas_id}/`)
  .then(response => response.json())
  .then(data => {
    // Set the text and color inputs based on the data received
    document.getElementById('canvasName').value = data.name;
    userText.value(data.user_text);
    textColor.value(data.text_color);
    bgColor.value(data.bg_color);

    if (data.word_objects && Array.isArray(data.word_objects)) {
      wordObjects = data.word_objects;
      console.log("Updated wordObjects:", wordObjects);

      // Assuming we have at least one word object to calculate the repeats
      if(wordObjects.length > 0) {
        // Calculate slider values based on the first word object
        let centerX = width / 2;
        let centerY = height / 2;
        let firstWord = wordObjects[0];
        
        let horizontalRepeats = Math.abs((firstWord.x - centerX) * (2 * int(horizontalSlider.value()) + 1) / width);
        let verticalRepeats = Math.abs((firstWord.y - centerY) * (2 * int(verticalSlider.value()) + 1) / height);

        horizontalSlider.value(horizontalRepeats);
        verticalSlider.value(verticalRepeats);
      }
    }

    // Call your update function to redraw the canvas
    updateWords();
    console.log('Should trigger a new draw now.');
    redraw();  // Force p5.js to execute draw()
    
    isEditing = false;  // We're done editing
  })
  .catch(error => console.log('Oh darlin\', something went wrong: ', error));
}



function updateCanvasState(canvas_id, canvasData) {
  fetch(`/wordupp/api/update/${canvas_id}/`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': csrftoken,
    },
    body: JSON.stringify(canvasData),
  })
  .then(response => response.json())
  .then(data => {
    console.log("Existing canvas updated:", data);
  });
}

function handleResettingAction() {
  wordObjects = [];  // Clear the array
  updateWords();  // Populate it based on new settings
  redraw();  // Redraw the canvas
}

function handleNonResettingAction() {
  // Update just the relevant properties
  for (const word of wordObjects) {
    word.color = textColor.value();
  }
  redraw();  // Redraw the canvas
}



</script>

{% endblock %}